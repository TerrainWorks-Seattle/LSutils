---
title: "Create Training Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Create Training Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(TerrainWorksUtils)
library(terra)
library(tidyterra)
library(ggplot2)
```


TerrainWorksUtils includes methods which can be helpful for extracting data 
from spatial objects which can be used to build predictive models like 
random forests. 

For this example, we will work with landslide susceptibility data from near
Scottsburg, Oregon. We have a Digital Elevation Model, and several raster 
files which contain data about slope metrics including gradient, 
plan curvature, profile curvature, deviation from mean elevation, and 
partial contributing area. For more details on these metrics, see the 
DEMUtilities toolbox. 

We also have a set of landslide initiation points, which we will use to train 
the model. 

TerrainWorksUtils uses the package `terra` for working with spatial data. 

```{r}
#load the data
data_path <- system.file("examples", package = "LSutils")
elev <- rast(file.path(data_path, "elevation.flt"))
gradient <- rast(file.path(data_path, "gradient.flt"))
mean_curv <- rast(file.path(data_path, "mean_curv.flt"))
pca <- rast(file.path(data_path, "pca_48.flt"))

vars_raster <- c(
  gradient,
  mean_curv,
  pca
)

initiation_points <- terra::vect(file.path(data_path,"initiation_points.shp"))
```

```{r, echo = FALSE, warning = FALSE, out.width= "75%", dpi = 300}
# create hillshade effect
slope <- terrain(elev, "slope", unit = "radians")
aspect <- terrain(elev, "aspect", unit = "radians")
hill <- shade(slope, aspect, 30, 270)

#plot
p <- ggplot() +
  theme_minimal() +
  geom_spatraster(data = hill, maxcell = Inf) +
  scale_fill_gradientn(colors = hcl.colors(1000, "Grays"), na.value = NA) +
  geom_spatvector(data = initiation_points, 
                  mapping = aes(fill = 1),
                  color = "red",
                  size = 2) +
  theme(legend.position = "none") 
p
```

To create training data, we need both initiation and non-initiation points. 
The methods `createTrainingDataFromPoints` and `createTrainingDataFromPolygons`
are the two main TerrainWorks functions for creating training data. In this
case, we are starting with a set of initiation points, so we will use the 
former. Under the hood, `createTrainingDataFromPoints` accepts a set of points
which are of a class we are trying to predict ("positive" points), samples 
"negative" points from our analysis region using the function
`sampleNegativePoints`, extracts values for each of those points, and formats
the result into a table. To extract more meaningful points, we can use the 
function `createAnalysisRegionMask` to filter our analysis region to only 
include cells which already contain reasonable values for landslides to occur. 

```{r analysisRegionMask}
analysis_region_mask <- create_analysis_region_mask(
  vars_raster, 
  initiation_points, 
  mask_vars = c("gradient", "mean_curv", "pca_48"), 
  expansion_factor = 1
)
ggplot() + 
  theme_minimal() + 
  geom_spatraster(data = analysis_region_mask) +
  scale_fill_gradientn(colors = c("lightblue"), na.value = NA) +
  theme(legend.position = "none")
```

Now that we have specified our analysis region, we can create our training 
data. 

```{r create-training-data}
all_points <- sample_negative_points(
  initiation_points, 
  analysis_region = analysis_region_mask
)
training_points <- extract_values(
  vars_raster, 
  all_points, 
  extraction_method = "centroid", 
  return_type = "points"
)
```

```{r}
p <- ggplot() +
  theme_minimal() +
  geom_spatraster(data = hill) +
  scale_fill_gradientn(colors = pal_greys, na.value = NA) +
  geom_spatvector(data = training_points[training_points$class == "positive"], 
                  mapping = aes(fill = 1),
                  color = "red",
                  size = 2) +
  geom_spatvector(data = training_points[training_points$class == "negative"], 
                  mapping = aes(fill = 1),
                  color = "black",
                  size = 2) +
  theme(legend.position = "none")
p
```

There are also functions included which simpify the process of creating training data into a single function call. Here, we get a data frame with the positive points, negative points, and the covariates

```{r}
create_training_data_with_buffer(positive_points = initiation_points,
  predictors_raster = vars_raster,
  analysis_region_mask = analysis_region_mask,
  rseed = 1)
```

